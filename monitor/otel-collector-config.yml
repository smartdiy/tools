# 1. EXTENSIONS: Tools that provide extra capabilities (like Health Checks)
extensions:
  health_check:
    endpoint: 0.0.0.0:13133 # Port used by Docker healthcheck

# 2. RECEIVERS: How the Collector gets data from your Spring App
receivers:
  otlp:
    protocols:
      grpc:
        endpoint: 0.0.0.0:4317
      http:
        endpoint: 0.0.0.0:4318

# 3. PROCESSORS: How to clean or batch data before sending
processors:
  batch:
    # Groups data to reduce network calls
    timeout: 5s
    send_batch_size: 1024

  # ARCHITECT TIP: Drop noisy health check spans so they don't flood Jaeger
  filter/drop_health:
    error_mode: ignore
    traces:
      span:
        - 'attributes["http.target"] == "/actuator/health"'
        - 'attributes["http.target"] == "/actuator/prometheus"'

# 4. EXPORTERS: Where the data goes (Jaeger, Prometheus, and Console)
exporters:
  # Traces go to Jaeger via gRPC
  otlp/jaeger:
    endpoint: jaeger:4317
    tls:
      insecure: true

  # Metrics are exposed for Prometheus to "scrape" (pull)
  prometheus:
    endpoint: "0.0.0.0:8889"

  # Logs and Traces go to Console for your WSL debugging
  debug:
    verbosity: detailed

# 5. SERVICE: The "Wiring Diagram" that connects everything
service:
  extensions: [health_check] # Enables the extension
  
  pipelines:
    # Trace Pipeline: Receivers -> Processors -> Exporters
    traces:
      receivers: [otlp]
      processors: [filter/drop_health, batch]
      exporters: [otlp/jaeger, debug]

    # Metrics Pipeline
    metrics:
      receivers: [otlp]
      processors: [batch]
      exporters: [prometheus, debug]

    # Logs Pipeline: Correlate logs with Traces in Jaeger
    logs:
      receivers: [otlp]
      processors: [batch]
      exporters: [otlp/jaeger, debug]
